# IBM Gate Circuit to DWave Annealer Embedding Translator

This project is described in detail in the paper "Automatically Translating Quantum Programs from a Subset of Common Gates to an Adiabatic Representation" by Malcolm Regan, Brody Eastwood, Mahita Nagabhiru, and Frank Mueller.

-----------------------------------------------------------------------------

## Running Qiskit scripts with the converter

1) To run or simulate generated embeddings DWave Ocean Python package is required. See https://docs.ocean.dwavesys.com/en/latest/overview/install.html.

2) To run examples, add base directory of repository to ```PYTHONPATH```, i.e. go to repository directory and type

      ```export PYTHONPATH=`pwd` ```

3) Set ```self.token``` variable at the top of the ```annealer_graph``` class in ```converter/qiskit/annealer_graph.py``` to your DWave token as a string, i.e.

      ```token = 'DEV-########################################'```

      This variable must be set to run generated embeddings on DWave hardware.

4) In Qiskit scripts to be translated, change the line ```import qiskit``` to ```import converter.qiskit```


5) Command line flags:

      ```sim``` flag - Run ExactSolver simulation of embedding
        
        python example_script.py sim
     
      Simulation requires that DWave Ocean be installed
     
      NOTE: ExactSolver simulations of embeddings comprised of more than 19 qubits is not recommended. It can take a very long time or cause your computer to crash. If simulation of an embedding with more than 19 qubits is attempted a warning is issued.
     
      ```run``` flag - Run generated embedding on DWave (this is default - no flag required) 
        
        python example_script.py run
      
      Running embeddings requires that DWave Ocean be installed and also requires a Dwave Ocean access token. 
      
      ```source``` flag -  Generate DWave Ocean script.
        
        python example_script.py source
       
      Running a script with the ```source``` flag will generate a Dwave ocean file, ```example_script_Dwave.py```, that can be used to debug or otherwise improve the generated embedding. This does not require DWave Ocean to be installed nor does it require an acess token.
        
      Any combination of these flags will work 
        
        python example_script.py run sim source


-----------------------------------------------------------------------------

## Example

The  sample  Qiskit  program  below  defines  a  1-qubit  adder  circuit.  Note  that  the  imports  have  been  modified  to  indicate  the  use of the gate-circuit-to-annealer embedding translator (i.e., ’```converter.qiskit```’ replaces ’```qiskit```’). This is the only modification that is required to run a Qiskit program with the translator code.


```
from converter.qiskit import QuantumRegister, ClassicalRegister
from converter.qiskit import QuantumCircuit, execute

# Input Registers: a = qi[0]; b = qi[1]; ci = qi[2]
qi = QuantumRegister(3)
ci = ClassicalRegister(3)

# Output Registers: s = qo[0]; co = qo[1]
qo = QuantumRegister(2)
co = ClassicalRegister(2)

circuit = QuantumCircuit(qi,qo,ci,co)

# Define adder circuit

for idx in range(3):
      circuit.ccx(qi[idx], qi[(idx+1)%3], qo[1])
for idx in range(3):
      circuit.cx(qi[idx], qo[0])

circuit.measure(qo, co)

# Run
execute(circuit)
```

The measure method is used as an indication that a given qubit register is considered a circuit output, which aids in organizing the results. When  the execute method  is called,  the  user  is  prompted  to  answer  whether  or  not  initial  values  of  qubits should be constrained to zero. Qubits are identified using Qiskit’s naming scheme and by the order with which they appeared in the initialization of the Quantum Circuit. In the case of the 1-qubit adder above, the user would like for the initial state of the sum and carry-out qubits be constrained to zero, and so responds to the prompts from execute as follows:

```
Constrain input of measured qubit q1_0 to be 0 (y/n)? y
Constrain input of measured qubit q1_1 to be 0 (y/n)? y
Constrain input of unmeasured qubit q0_0 to be 0 (y/n)? n
Constrain input of unmeasured qubit q0_1 to be 0 (y/n)? n
Constrain input of unmeasured qubit q0_2 to be 0 (y/n)? n
```

Next, the user is prompted to specify the number of anneals that they would like to run. For the 1-qubit adder, 400 has been found to be sufficient.

If no command line flags were given or the ```run``` command line flag is given, the embedding is submitted to DWave hardware and annealed. The  results  of  annealing  the  embedding  generated  by  the  Qiskit  program are then reported. The results of the embedding generated by the 1-qubit adderprogram above are shown below:

```
[0, 0, 0, 0, 0]
[0, 0, 1, 1, 0]
[0, 1, 0, 1, 0]
[0, 1, 1, 0, 1]
[1, 0, 0, 1, 0]
[1, 0, 1, 0, 1]
[1, 1, 0, 0, 1]
[1, 1, 1, 1, 1]
```

Results are presented with inputs on the left and outputs on the right, in the order that they were listed when QuantumCircuit was initialized in the Qiskit script. The columns of the results then, from left to right, correspond to qubits a, b, ci, s, and co. Note that if the initial state of an output is not constrained to zero by the user, its initial state is reported as an input

If the ```sim``` command line flag is given, an attempt to run ExactSolver on the embedding will be made. However, the 1-qubit adder is too large and will either take an unreasonable amount of time or cause your computer to crash.

If the ```source``` command line flag is given, a script which defines and runs the generated embedding is created. This can allow the user to debug or otherwise improve the generated embedding. For the 1-qubit adder example, please see the generated source script, ```one_qubit_adder_Dwave.py```, in the examples directory. When this file is run, the defined embedding is submitted to DWave hardware, annealed, and results are reported in the same way that was described above.

-----------------------------------------------------------------------------

## Notes

- Due to limitations of the current mapping algorithm, Qiskit gate circuit definitions should be written so that gate operations on a given qubit happen as closely to eachother as possible. This eliminates the need for long chains in the embedding, which crowd the graph and sometimes cannot be routed successfully to their destination. Further, long chains have been demonstrated to prevent an embedding from being able to anneal down to all of its ground states.
- When the mapping algorithm attempts to make a connection that it cannot make, this is reported as an error message. Often however, when this error is encountered, another valid connection is made and the generated embedding will work.
- Before an embedding is generated, the user is prompted to answer whether or not the mapping algorithm should avoid gate cells that contain broken qubits or gate cells that contain qubits with broken couplers. Sometimes the mapping goes smoother if these cells are avoided and sometimes it works better if they are not. The proper answers to these prompts depend on where the faulty graph elements are located and what the gate circuit definition is. 

-----------------------------------------------------------------------------

## To Do

- Improve mapping algorithm
- Implement graph reduction
- Extend set of translatable gates

-----------------------------------------------------------------------------

## License

